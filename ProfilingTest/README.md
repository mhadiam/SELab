<div dir="rtl">
  
  با اجرای `JavaCup` و وارد کردن ۳ عدد ارور `java.lang.OutOfMemoryError: Java heap space` را می‌گیریم.
  با بررسی میزان مصرف حافظه در پروفایلینگ **YourKit** مشخص است که هنگام فراخوانی تابع `JavaCup.temp` این اتفاق روی داده است.
<img width="1548" alt="Screenshot 2025-05-09 at 9 54 32 PM" src="https://github.com/user-attachments/assets/2be55d76-892b-4eb7-ba9a-efa4e7bff4b1" />
برای بهبود عملکرد تابع `add` در آرایه `initialCapacity` را موقع ساخت آرایه ست می‌کنیم تا بیش از نیازمان فضا به آرایه اختصاص داده نشود (به دلیل دوبرابر شدن آرایه ممکن است مقدار درخواستی بیش از نیاز باشد):
```java
...
ArrayList a = new ArrayList(200_000_000);
...
```


حال یک آرایه به طول ۱۰۰ میلیون داریم که می‌خواهیم یک عنصر را در آن جستجو کنیم (یکی مانده با آخر). الگوریتم جستجو را یک بار با جستجوی خطی و بار دیگر با جستجوی دودویی اجرا می‌کنیم تا مقایسه کنیم.
<img width="1387" alt="Screenshot 2025-05-09 at 10 44 54 PM" src="https://github.com/user-attachments/assets/3db77367-38de-4c8e-98e3-9d7d1d83db5a" />

<img width="1383" alt="Screenshot 2025-05-09 at 10 47 27 PM" src="https://github.com/user-attachments/assets/6886a17e-00f5-4e9a-b5bb-82b5146c813a" />


در تصاویر بالا تغییر محسوس زمان اجرای جستجو را می‌بینیم که در جستجوی خطی ۲۴۴ میلی‌ثانیه و در جستجوی دودویی ۱۶۳ میلی‌ثانیه طول کشیده است. مصرف حافظه هردو الگوریتم تقریبا یکسان است با توجه به این که صرفا چند متغیر لوکال دارند و هردو یک آرایه بزرگ از اعداد را دارند که متغیر‌های لوکال در برابر آنها هیچ حساب نمی‌شوند.
</div>
