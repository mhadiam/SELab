<div dir="rtl">

# بخش اول: پیاده‌سازی الگوی Adapter
## زیربخش یک
الگوی طراحی adapter به شکل object scope است. چون که در زبان جاوا ارث‌بری محدود است (بیشتر از یک والد نمیشود) که در این صورت وابستگی به والد زیاد می‌شود و آزادی کد زدن کمتر میشود. همچنین منعطف بودن این روش نسبت به class scope واضح است چون می‌توان با composition از آبجکت استفاده دوباره داشت به جای ساختن یک آبجکت جدید. در نهایت در کل composition به inheritance ترجیح داده می‌شود و توصیه می‌شود اگر استفاده از ارث‌بری لازم نباشد.

## زیربخش دو
ابتدا یک interface به نام GraphAdapter ساختم از توابعی که قرار بود مشترک باشند و برای هر کتابخانه جداگانه پیاده‌سازی شوند. سپس با توجه به اینکه نیازی به ارث‌بری نبود، با ترکیب کلاس‌ها (Composition) دو کلاس به عنوان واسط هر کتابخانه تعریف کردم به نام‌های JungGraphAdapter و JGraphTGraphAdapter که به کتابخانه‌های مربوطه متصل میشوند. سپس در این دو واسط توابع مورد نیاز را به شکل مخصوص خودش پیاده کردم.

# بخش دوم: 
تغییر کتابخانه ابتدا در کد اصلی و جایی که گراف‌ ساخته می‌شود بازتاب می‌کند و سعی میشود که باقی تغییرات به پشت آداپتر برده شوند تا تاثیر ناشی از تغییر کتابخانه در کد اصلی به حداقل برسد. در `Main.java` دو وجود دارد که مقداردهی آنها باعث میشود کتابخانه عوض شود. یکی از آنها را کامنت کرده‌ام که می‌توان عوضشان کرد. سپس جایی که یال‌ها ساخته می‌شوند، به دلیل اینکه دو کتابخانه رویکرد متفاوتی برای ساخت یال داشتند، اطلاعات مورد نیاز را در کد اصلی نگه داشتم و باقی اطلاعات (مانند نام یال) را به آداپتر مربوطه بردم. باقی کد اصلی دست نخورده باقی مانده است. سپس در دو تابع DFSTraverser و BFSTraverser تایپ گراف را یکسان کردم (GraphAdapter) تا تغییر کتابخانه اثری در کارکرد آنها نگذارد.

# بخش سوم:
۱: وقتی یک کاری به چند روش قابل انجام است (مانند سورت کردن با الگوریتم‌های مختلف)، می‌شود به جای اینکه در سطح کلاینت با if/else آنها را انجام داد، با استفاده از روش strategy پیاده‌سازی روش‌های گوناگون را encapsulate کرد تا کلاینت به راحتی بتواند بین آنها سوییچ کند (هنگام runtime). بنابراین هم ساختار کد زیباتر می‌شود و هم راحت‌تر برای استفاده نهایی.

۲: برای ساخت این الگو در این پروژه (و در کل این شکلیست) یک interface واحد (در اینجا Traverser) که کاربر نهایی با آن سر و کار دارد ساخته می‌شود و کدهای گوناگون که قصد یکسانی دارند آن را پیاده می‌کنند. برای مثلا در جاوا بسیاری از کلاس‌ها ممکن است مقایسه شوند بنابراین از یک interface به نام comparable استفاده می‌کنند تا در هنگام اجرای کد منعطف و قابل تعویض باشند. سپس دو تابع DFS و BFS توابع آن اینترفیس را پیاده‌سازی می‌کنند. در هنگام اجرای کد اصلی صرفا کلاسی که این اینترفیس را پیاده‌سازی کرده باشد لازم است و مهم نیست که از کدام روش استفاده شده چون هردو در رانتایم قابل اجرا هستند.

</div>
