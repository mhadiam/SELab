<div dir="rtl">

# بخش اول: پیاده‌سازی الگوی Adapter
## زیربخش یک
الگوی طراحی adapter به شکل object scope است. چون که در زبان جاوا ارث‌بری محدود است (بیشتر از یک والد نمیشود) که در این صورت وابستگی به والد زیاد می‌شود و آزادی کد زدن کمتر میشود. همچنین منعطف بودن این روش نسبت به class scope واضح است چون می‌توان با composition از آبجکت استفاده دوباره داشت به جای ساختن یک آبجکت جدید. در نهایت در کل composition به inheritance ترجیح داده می‌شود و توصیه می‌شود اگر استفاده از ارث‌بری لازم نباشد.

## زیربخش دو
ابتدا یک interface به نام GraphAdapter ساختم از توابعی که قرار بود مشترک باشند و برای هر کتابخانه جداگانه پیاده‌سازی شوند. سپس با توجه به اینکه نیازی به ارث‌بری نبود، با ترکیب کلاس‌ها (Composition) دو کلاس به عنوان واسط هر کتابخانه تعریف کردم به نام‌های JungGraphAdapter و JGraphTGraphAdapter که به کتابخانه‌های مربوطه متصل میشوند. سپس در این دو واسط توابع مورد نیاز را به شکل مخصوص خودش پیاده کردم.

# بخش دوم: 
تغییر کتابخانه ابتدا در کد اصلی و جایی که گراف‌ ساخته می‌شود بازتاب می‌کند و سعی میشود که باقی تغییرات به پشت آداپتر برده شوند تا تاثیر ناشی از تغییر کتابخانه در کد اصلی به حداقل برسد. در `Main.java` دو وجود دارد که مقداردهی آنها باعث میشود کتابخانه عوض شود. یکی از آنها را کامنت کرده‌ام که می‌توان عوضشان کرد. سپس جایی که یال‌ها ساخته می‌شوند، به دلیل اینکه دو کتابخانه رویکرد متفاوتی برای ساخت یال داشتند، اطلاعات مورد نیاز را در کد اصلی نگه داشتم و باقی اطلاعات (مانند نام یال) را به آداپتر مربوطه بردم. باقی کد اصلی دست نخورده باقی مانده است. سپس در دو تابع DFSTraverser و BFSTraverser تایپ گراف را یکسان کردم (GraphAdapter) تا تغییر کتابخانه اثری در کارکرد آنها نگذارد.

</div>
